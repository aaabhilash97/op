// The following directive is necessary to make the package coherent:

// +build ignore

// This program generates *.operations.go. It can be invoked by running
// go generate

package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"html/template"
	"io/ioutil"
	"log"
	"os"
	"strings"

	"github.com/fatih/structtag"
)

type fieldSpec struct {
	Name            string
	BsonTagName     string
	Type            string
	SubStructFields []struct {
		Name        string
		BsonTagName string
	}
}
type Node struct {
	Name     string
	Pos      int
	IsStruct bool
	Fields   []fieldSpec
}

func findModel(models []Node, name string) *Node {
	for _, model := range models {
		if model.Name == name {
			return &model
		}
	}
	return nil
}
func main() {
	dat, err := ioutil.ReadFile("gen/base-model.operations.go")

	if err != nil {
		log.Fatal(err)
	}

	baseModel := string(dat)

	files, err := ioutil.ReadDir("./")
	if err != nil {
		log.Fatal(err)
	}

	for _, f := range files {
		if !f.IsDir() {
			dat, err := ioutil.ReadFile(f.Name())
			if err != nil {
				panic(err)
			}
			models := extractModels(string(dat))
			for _, model := range models {
				modelName := string(model.Name)
				if strings.HasSuffix(model.Name, "Model") {
					newModel := strings.ReplaceAll(baseModel, "BaseModel", modelName)

					newFile, err := os.Create(modelName + ".operations.go")
					if err != nil {
						panic(err)
					}
					defer newFile.Close()
					newFile.Write([]byte(newModel))
					if err != nil {
						panic(err)
					}

					err = os.Rename(f.Name(), modelName+".go")
					if err != nil {
						panic(err)
					}
					for modelIndex, model := range models {
						for fieldIndex, field := range model.Fields {
							if m := findModel(models, field.Type); m != nil && m.IsStruct {
								for _, innerField := range m.Fields {
									models[modelIndex].Fields[fieldIndex].SubStructFields = append(field.SubStructFields, struct {
										Name        string
										BsonTagName string
									}{
										Name:        innerField.Name,
										BsonTagName: innerField.BsonTagName,
									})
								}
							}
						}

					}
					{
						metaCode := `// Code generated by db/gen/gen.go; DO NOT EDIT.
package db
{{range $val := .Fields}}
func (model {{$.Name}}) {{$val.Name}}Tag() string {
	return "{{$val.BsonTagName}}"
}
{{end}}`

						// {{range $field := .Fields}}{{range $sub_field := $field.SubStructFields}}
						// func (model {{$.Name}}) {{$field.Name}}{{$sub_field.Name}}Tag() string {
						// 	return "{{$field.BsonTagName}}.{{$sub_field.BsonTagName}}"
						// }
						// {{end}}{{end}}
						newFile, err := os.Create(modelName + ".meta.go")
						if err != nil {
							panic(err)
						}
						defer newFile.Close()

						t := template.Must(template.New("tmpl").Parse(metaCode))
						t.Execute(newFile, model)

					}
				}
			}
		}
	}

}

func extractModels(src string) []Node {
	fset := token.NewFileSet() // positions are relative to fset
	f, err := parser.ParseFile(fset, "", src, 0)
	if err != nil {
		fmt.Println(">>>", src)
		panic(err)
	}

	models := make([]Node, 0)
	var pendingNode Node
	// Inspect the AST and print all identifiers and literals.
	ast.Inspect(f, func(n ast.Node) bool {
		switch x := n.(type) {
		case *ast.StructType:

			if int(x.Pos()) == pendingNode.Pos {
				pendingNode.IsStruct = true
				for _, field := range x.Fields.List {
					if strings.ToUpper(field.Names[0].Name[:1])[0] == field.Names[0].Name[0] {
						structField := fieldSpec{
							Name: field.Names[0].Name,
						}
						if field.Tag == nil {
							continue
						}
						tag := strings.Trim(field.Tag.Value, "`")
						tags, err := structtag.Parse(tag)
						if err != nil {
							panic(err)
						}
						// iterate over all tags
						for _, t := range tags.Tags() {
							if t.Key == "bson" {
								structField.BsonTagName = t.Name
							}

						}
						if fieldT, ok := field.Type.(*ast.StarExpr); ok {
							structField.Type = strings.Trim(string(src[fieldT.Pos():fieldT.End()]), " ")
						}
						pendingNode.Fields = append(pendingNode.Fields, structField)
					}
				}
				models = append(models, pendingNode)
			}

		case *ast.TypeSpec:
			pendingNode = Node{
				Name: x.Name.Name,
				Pos:  int(x.Type.Pos()),
			}
		}
		return true
	})
	return models
}
