// Code generated by modelservice/gen/gen.go; DO NOT EDIT.

package db

import (
	"context"
	"time"

	"github.com/aaabhilash97/op/pkg/logger"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
	"go.uber.org/zap"
)

// GetCollectionName - get collection name
func (model *BaseModel) GetCollectionName() string {
	return model.collection.Name()
}

// SetUpdatedAt - Set updated at
func (model *BaseModel) SetUpdatedAt() {
	curTime := time.Now()
	model.UpdatedAt = &curTime
}

// Find - to find
func (model *BaseModel) Find(query interface{}, opts ...*options.FindOptions) ([]*BaseModel, error) {
	fn := "BaseModel-Find"
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()
	cur, err := model.collection.Find(ctx, query, opts...)
	if err != nil {
		logger.Error(fn, zap.Error(err))
		return nil, ParseError(err)
	}
	defer cur.Close(ctx)
	results := []*BaseModel{}
	for cur.Next(ctx) {
		var result BaseModel
		err = cur.Decode(&result)
		if err != nil {
			logger.Error(fn, zap.Error(err))
			return nil, ParseError(err)
		}
		results = append(results, &result)
	}
	if err := cur.Err(); err != nil {
		logger.Error(fn, zap.Error(err))
		return nil, ParseError(err)
	}
	return results, nil
}

// Find - to find
func (model *BaseModel) FindStream(query interface{}, result chan<- struct {
	Val BaseModel
	Err error
}, opts ...*options.FindOptions) {
	fn := "BaseModel-Find"
	defer close(result)
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()
	cur, err := model.collection.Find(ctx, query, opts...)
	if err != nil {
		logger.Error(fn, zap.Error(err))
		result <- struct {
			Val BaseModel
			Err error
		}{
			Err: ParseError(err),
		}
		return
	}
	defer cur.Close(ctx)

	for cur.Next(ctx) {
		var item BaseModel
		err = cur.Decode(&item)
		if err != nil {
			logger.Error(fn, zap.Error(err))
			result <- struct {
				Val BaseModel
				Err error
			}{
				Err: ParseError(err),
			}
			return
		}
		result <- struct {
			Val BaseModel
			Err error
		}{
			Val: item,
		}
	}
	if err = cur.Err(); err != nil {
		logger.Error(fn, zap.Error(err))
		result <- struct {
			Val BaseModel
			Err error
		}{
			Err: ParseError(err),
		}
		return
	}
}

func (model *BaseModel) Distinct(fieldName string, query interface{}, opts ...*options.DistinctOptions) ([]interface{}, error) {
	fn := "BaseModel-Find"
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()
	entries, err := model.collection.Distinct(ctx, fieldName, query, opts...)
	if err != nil {
		logger.Error(fn, zap.Error(err))
		return nil, ParseError(err)
	}

	return entries, nil
}

// FindOne - to findOne
func (model *BaseModel) FindOne(query interface{}, opts ...*options.FindOneOptions) (*BaseModel, error) {
	fn := "BaseModel-FindOne"
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	result := BaseModel{}
	err := model.collection.FindOne(ctx, query, opts...).Decode(&result)
	if err != nil {
		logger.Error(fn, zap.Error(err))
		return nil, ParseError(err)
	}

	return &result, nil
}

// FindOne - to findOne
func (model *BaseModel) FindOneTxn(sc mongo.SessionContext, query interface{}, opts ...*options.FindOneOptions) (*BaseModel, error) {
	fn := "BaseModel-FindOne"
	result := BaseModel{}
	err := model.collection.FindOne(sc, query, opts...).Decode(&result)
	if err != nil {
		logger.Error(fn, zap.Error(err))
		return nil, ParseError(err)
	}

	return &result, nil
}

// InsertOne -
func (model *BaseModel) InsertOne(value BaseModel, opts ...*options.InsertOneOptions) (primitive.ObjectID, error) {
	fn := "BaseModel-InsertOne"
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	res, err := model.collection.InsertOne(ctx, value, opts...)
	if err != nil {
		logger.Error(fn, zap.Error(err))
		return primitive.NilObjectID, ParseError(err)
	}
	id := res.InsertedID.(primitive.ObjectID)

	return id, nil
}

// UpdateOne -
func (model *BaseModel) UpdateOne(query interface{}, value interface{}, options ...*options.UpdateOptions) (*mongo.UpdateResult, error) {
	fn := "BaseModel-UpdateOne"

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	res, err := model.collection.UpdateOne(ctx, query, value, options...)
	if err != nil {
		logger.Error(fn, zap.Error(err))
		return nil, ParseError(err)
	}

	return res, nil
}

// UpdateMany -
func (model *BaseModel) UpdateMany(query interface{}, value interface{}, options ...*options.UpdateOptions) (*mongo.UpdateResult, error) {
	fn := "BaseModel-UpdateMany"

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	res, err := model.collection.UpdateMany(ctx, query, value, options...)
	if err != nil {
		logger.Error(fn, zap.Error(err))
		return nil, ParseError(err)
	}

	return res, nil
}

// UpdateManyTxn -
func (model *BaseModel) UpdateManyTxn(sc mongo.SessionContext, query interface{}, value interface{}, options ...*options.UpdateOptions) (*mongo.UpdateResult, error) {
	fn := "BaseModel-UpdateManyTxn"

	res, err := model.collection.UpdateMany(sc, query, value, options...)
	if err != nil {
		logger.Error(fn, zap.Error(err))
		return nil, ParseError(err)
	}

	return res, nil
}

// DeleteOne - to DeleteOne
func (model *BaseModel) DeleteOne(filter interface{}, opts ...*options.DeleteOptions) (*mongo.DeleteResult, error) {
	fn := "BaseModel-DeleteOne"
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	result, err := model.collection.DeleteOne(ctx, filter, opts...)

	if err != nil {
		logger.Error(fn, zap.Any("error", err))
		return nil, ParseError(err)
	}

	return result, nil
}

// DeleteMany -
func (model *BaseModel) DeleteMany(filter interface{}, opts ...*options.DeleteOptions) (*mongo.DeleteResult, error) {
	fn := "BaseModel-DeleteMany"
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	result, err := model.collection.DeleteMany(ctx, filter, opts...)

	if err != nil {
		logger.Error(fn, zap.Any("error", err))
		return nil, ParseError(err)
	}

	return result, nil
}

// DeleteOneTxn - to DeleteOne
func (model *BaseModel) DeleteManyTxn(sc mongo.SessionContext, filter interface{}, opts ...*options.DeleteOptions) (*mongo.DeleteResult, error) {
	fn := "BaseModel-DeleteManyTxn"

	result, err := model.collection.DeleteMany(sc, filter, opts...)

	if err != nil {
		logger.Error(fn, zap.Any("error", err))
		return nil, ParseError(err)
	}

	return result, nil
}

// Aggregate - mongodb aggregate
func (model *BaseModel) Aggregate(pipeline interface{}, opts ...*options.AggregateOptions) ([]BaseModel, error) {
	fn := "BaseModel-Aggregate"
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()
	cur, err := model.collection.Aggregate(ctx, pipeline, opts...)
	if err != nil {
		logger.Error(fn, zap.Error(err))
		return nil, ParseError(err)
	}
	defer cur.Close(ctx)
	results := []BaseModel{}
	for cur.Next(ctx) {
		var result BaseModel
		err = cur.Decode(&result)
		if err != nil {
			logger.Error(fn, zap.Error(err))
			return nil, ParseError(err)
		}
		results = append(results, result)
	}
	if err := cur.Err(); err != nil {
		logger.Error(fn, zap.Error(err))
		return nil, ParseError(err)
	}
	return results, nil
}

// Aggregate - mongodb aggregate
func (model *BaseModel) AggregateStream(pipeline interface{}, resultChan chan<- struct {
	Val BaseModel
	Err error
}, opts ...*options.AggregateOptions) {
	fn := "BaseModel-Aggregate"
	defer close(resultChan)
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()
	cur, err := model.collection.Aggregate(ctx, pipeline, opts...)
	if err != nil {
		logger.Error(fn, zap.Error(err))
		resultChan <- struct {
			Val BaseModel
			Err error
		}{
			Err: ParseError(err),
		}
		return
	}
	defer cur.Close(ctx)

	for cur.Next(ctx) {
		var item BaseModel
		err = cur.Decode(&item)
		if err != nil {
			logger.Error(fn, zap.Error(err))
			resultChan <- struct {
				Val BaseModel
				Err error
			}{
				Err: ParseError(err),
			}
			return
		}
		resultChan <- struct {
			Val BaseModel
			Err error
		}{
			Val: item,
		}
	}
	if err = cur.Err(); err != nil {
		logger.Error(fn, zap.Error(err))
		resultChan <- struct {
			Val BaseModel
			Err error
		}{
			Err: ParseError(err),
		}
		return
	}
}

// InsertOneTxn -
func (model *BaseModel) InsertOneTxn(sc mongo.SessionContext, value BaseModel, opts ...*options.InsertOneOptions) (primitive.ObjectID, error) {
	fn := "BaseModel-InsertOneTxn"

	res, err := model.collection.InsertOne(sc, value, opts...)
	if err != nil {
		logger.Error(fn, zap.Error(err))
		return primitive.NilObjectID, ParseError(err)
	}
	id := res.InsertedID.(primitive.ObjectID)

	return id, nil
}

// UpdateOneTxn -
func (model *BaseModel) UpdateOneTxn(sc mongo.SessionContext, query interface{}, value interface{}, options ...*options.UpdateOptions) (*mongo.UpdateResult, error) {
	fn := "BaseModel-UpdateOneTxn"

	res, err := model.collection.UpdateOne(sc, query, value, options...)
	if err != nil {
		logger.Error(fn, zap.Error(err))
		return nil, ParseError(err)
	}

	return res, nil
}

// DeleteOneTxn - to DeleteOne
func (model *BaseModel) DeleteOneTxn(sc mongo.SessionContext, filter interface{}, opts ...*options.DeleteOptions) (*mongo.DeleteResult, error) {
	fn := "BaseModel-DeleteOneTxn"

	result, err := model.collection.DeleteOne(sc, filter, opts...)

	if err != nil {
		logger.Error(fn, zap.Any("error", err))
		return nil, ParseError(err)
	}

	return result, nil
}

// FindOneAndUpdateTxn -
func (model *BaseModel) FindOneAndUpdateTxn(sc mongo.SessionContext, query interface{}, value interface{}, options ...*options.FindOneAndUpdateOptions) (*BaseModel, error) {
	fn := "BaseModel-UpdateOneTxn"

	res := model.collection.FindOneAndUpdate(sc, query, value, options...)
	if res == nil {
		logger.Error(fn, zap.String("error", "Empty single result"))

	}
	if err := res.Err(); err != nil {
		logger.Error(fn, zap.Error(err))
		return nil, ParseError(err)
	}

	result := &BaseModel{}
	if err := res.Decode(result); err != nil {
		logger.Error(fn, zap.Error(err))
		return nil, ParseError(err)
	}

	return result, nil
}

// FindOneAndUpdate -
func (model *BaseModel) FindOneAndUpdate(query interface{}, value interface{}, options ...*options.FindOneAndUpdateOptions) (*BaseModel, error) {
	fn := "BaseModel-UpdateOneTxn"
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()
	res := model.collection.FindOneAndUpdate(ctx, query, value, options...)
	if res == nil {
		logger.Error(fn, zap.String("error", "Empty single result"))
	}
	if err := res.Err(); err != nil {
		logger.Error(fn, zap.Error(err))
		return nil, ParseError(err)
	}

	result := &BaseModel{}
	if err := res.Decode(result); err != nil {
		logger.Error(fn, zap.Error(err))
		return nil, ParseError(err)
	}

	return result, nil
}

func (model *BaseModel) BulkWrite(models []mongo.WriteModel, opts ...*options.BulkWriteOptions) (*mongo.BulkWriteResult, error) {
	fn := "BaseModel-BulkWrite"
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	res, err := model.collection.BulkWrite(ctx, models, opts...)
	if err != nil {
		logger.Error(fn, zap.Error(err))
		return nil, ParseError(err)
	}
	return res, err
}

func (model *BaseModel) Watch(ctx context.Context, pipeline interface{}, opts ...*options.ChangeStreamOptions) (*mongo.ChangeStream, error) {
	fn := "BaseModel-Watch"

	cs, err := model.collection.Watch(ctx, pipeline, opts...)
	if err != nil {
		logger.Error(fn, zap.Error(err))
		return nil, ParseError(err)
	}
	return cs, err
}
